'''
그리디 문제가 아니다.
나눌 수 있는 큰 수로 먼저 나눈다고 최소 연산을 보장하지 않는다.
반례 : 26
26 -> 13 -> 12 -> 4 -> 2 -> 1 : 5회, 26 -> 25 -> 5 -> 1 : 3회

=> 모든 경우의 수를 계산해야 하는 완전탐색 문제이다.
=> 그런데 ... 문제를 풀기 전에 도식화해보면 같은 값을 여러 번 계산하게 되는 것을 확인할 수 있다.
=> 다이나믹 프로그래밍을 효과적으로 사용할 수 있다.
'''

x = int(input())

d = [0] * (x+1)

for i in range(2, x + 1):

    d[i] = d[i - 1] + 1

    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)

    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)

    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)
        
print(d[x])