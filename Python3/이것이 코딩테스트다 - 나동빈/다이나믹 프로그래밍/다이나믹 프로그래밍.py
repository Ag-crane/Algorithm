'''
다이나믹 프로그래밍(DP)
: 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결한다
=> 중복 연산을 피해서 연산 속도를 대폭 증가시킨다

사용 조건
- 큰 문제를 작은 문제로 나눌 수 있다
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

메모이제이션(=캐싱)
: 한 번 계산한 결과를 메모리 공간에 기록해 놓고 
같은 식을 다시 호출하면 기록된 결과값을 그대로 가져오는 기법
탑다운 방식에 국한되어 사용되는 표현이다

문제 해결 전략
- 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는 지 확인한다
- 부분 문제로 나눌 수 있는지, 부분 문제들이 중복되는지 확인한다
- 탑다운 : 일단 단순히 재귀함수로 비효율적인 프로그램을 작성한 뒤,
작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 즉 메모이제이션을 적용할 수 있으면 코드를 개선한다
- 보텀업 방식으로 구현하는 것이 일반적으로 낫다.
시스템상 재귀함수의 스택 크기가 한정되어 있으면 recursion depth 관련 오류가 발생할 수 있기 때문
- sys 라이브러리의 setrecursionlimit() 함수를 호출하여 재귀 제환을 완화할 수 있다

'''

# 일반적인 피보나치 수열 (점화식을 그대로 구현)
def fibo(x):
    if x==0 or x==1:
        return 1
    return fibo(x-1) + fibo(x-2)

## Top-Down 방식 DP : 큰 문제를 해결하기 위해 작은 문제를 호출한다
# 피보나치 수열 - 재귀함수 이용
def recursive_fibo(x):
    d = [0]*100     # 메모이제이션을 위한 리스트 초기화
    if x==1 or x==2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = recursive_fibo(x-1) + recursive_fibo(x-2)
    return d[x]

## Bottom-Up 방식 : 작은 문제부터 차근차근 답을 도출한다
# 피보나치 수열 - 반복문 이용
def iterative_fibo(x):
    d = [0]*100     # 계산 결과를 저장하기 위한 'DP 테이블' 초기화
    d[1] = 1
    d[2] = 1
    for i in range(3,x+1):
        d[i] = d[i-1] + d[i-2]
    return d[x]
    